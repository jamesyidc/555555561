<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ” é€æ­¥è°ƒè¯• - æ‰¾å‡º84çš„æ¥æº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #0f0;
            padding: 20px;
            font-size: 14px;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        .header {
            background: #1a1a1a;
            padding: 20px;
            border: 2px solid #0f0;
            margin-bottom: 20px;
        }
        .step {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #666;
        }
        .step.running {
            border-left-color: #ff0;
            background: #2a2a00;
        }
        .step.success {
            border-left-color: #0f0;
            background: #002a00;
        }
        .step.error {
            border-left-color: #f00;
            background: #2a0000;
        }
        .step-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #0ff;
        }
        .data {
            margin: 5px 0;
            padding: 5px;
            background: #000;
        }
        .highlight {
            color: #ff0;
            font-weight: bold;
        }
        .error {
            color: #f00;
            font-weight: bold;
        }
        .success {
            color: #0f0;
            font-weight: bold;
        }
        .button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 5px;
        }
        .button:hover {
            background: #0ff;
        }
        .array-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .array-item {
            background: #333;
            padding: 5px 10px;
            border: 1px solid #666;
        }
        .array-item.highlight {
            background: #ff0;
            color: #000;
            font-weight: bold;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison-box {
            background: #000;
            padding: 20px;
            border: 3px solid #666;
        }
        .comparison-box.match {
            border-color: #0f0;
        }
        .comparison-box.mismatch {
            border-color: #f00;
        }
        .bignum {
            font-size: 48px;
            text-align: center;
            margin: 20px 0;
        }
        pre {
            background: #000;
            padding: 10px;
            overflow-x: auto;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” é€æ­¥è°ƒè¯• Tooltip é—®é¢˜ - æ‰¾å‡º 84 çš„æ¥æº</h1>
            <p>æŒ‰æ­¥éª¤æ‰§è¡Œï¼ŒæŸ¥çœ‹æ¯ä¸€æ­¥çš„æ•°æ®çŠ¶æ€</p>
            <div style="margin-top: 10px;">
                <button class="button" onclick="runAll()">â–¶ å…¨éƒ¨è¿è¡Œ</button>
                <button class="button" onclick="runStep(currentStep + 1)">â­ ä¸‹ä¸€æ­¥</button>
                <button class="button" onclick="reset()">ğŸ”„ é‡ç½®</button>
            </div>
        </div>

        <div id="steps"></div>
    </div>

    <script>
        let currentStep = 0;
        let stepData = {};

        const steps = [
            {
                name: "æ­¥éª¤ 1: è·å–å½“å‰æ—¥æœŸ",
                run: async () => {
                    const currentDate = new Date().toISOString().split('T')[0];
                    const prevDateObj = new Date(currentDate + 'T00:00:00');
                    prevDateObj.setDate(prevDateObj.getDate() - 1);
                    const prevDate = prevDateObj.toISOString().split('T')[0];
                    
                    stepData.currentDate = currentDate;
                    stepData.prevDate = prevDate;
                    
                    return `å½“å‰æ—¥æœŸ: ${currentDate}\nå‰ä¸€å¤©: ${prevDate}`;
                }
            },
            {
                name: "æ­¥éª¤ 2: åŠ è½½ API æ•°æ®",
                run: async () => {
                    const [chartDataResp, prevDataResp] = await Promise.all([
                        fetch(`/api/signal-timeline/data?date=${stepData.currentDate}`),
                        fetch(`/api/signal-timeline/data?date=${stepData.prevDate}`)
                    ]);
                    
                    const chartData = await chartDataResp.json();
                    const prevData = await prevDataResp.json();
                    
                    stepData.chartData = chartData;
                    stepData.prevData = prevData;
                    
                    return `${stepData.currentDate}: ${chartData.data?.length || 0} æ¡æ•°æ®\n${stepData.prevDate}: ${prevData.data?.length || 0} æ¡æ•°æ®`;
                }
            },
            {
                name: "æ­¥éª¤ 3: åˆå¹¶å¹¶å»é‡æ•°æ®",
                run: async () => {
                    const combinedData = [...(stepData.prevData.data || []), ...(stepData.chartData.data || [])];
                    const uniqueTimeMap = new Map();
                    combinedData.forEach(item => {
                        uniqueTimeMap.set(item.time, item);
                    });
                    const deduplicatedData = Array.from(uniqueTimeMap.values()).sort((a, b) => {
                        return a.time < b.time ? -1 : 1;
                    });
                    
                    stepData.allData = deduplicatedData;
                    stepData.displayData = stepData.chartData.data || [];
                    
                    return `åˆå¹¶å‰: ${combinedData.length} æ¡\nå»é‡å: ${deduplicatedData.length} æ¡\nallData: ${stepData.allData.length} æ¡\ndisplayData: ${stepData.displayData.length} æ¡`;
                }
            },
            {
                name: "æ­¥éª¤ 4: ğŸ” æ£€æŸ¥æœ€åä¸€ä¸ª displayData ç‚¹",
                run: async () => {
                    const lastDisplay = stepData.displayData[stepData.displayData.length - 1];
                    stepData.lastDisplayPoint = lastDisplay;
                    
                    return `æœ€åä¸€ä¸ªæ˜¾ç¤ºç‚¹:\ntime: ${lastDisplay.time}\ncoin: ${lastDisplay.coin}\nsignal_type: ${lastDisplay.signal_type}`;
                }
            },
            {
                name: "æ­¥éª¤ 5: ğŸ” è®¡ç®—æœ€åä¸€ä¸ªç‚¹çš„ 24h çª—å£",
                run: async () => {
                    const lastDisplay = stepData.lastDisplayPoint;
                    const currentTime = new Date(lastDisplay.time);
                    const time24hAgo = new Date(currentTime - 24 * 60 * 60 * 1000);
                    
                    stepData.currentTime = currentTime;
                    stepData.time24hAgo = time24hAgo;
                    
                    return `å½“å‰æ—¶é—´: ${currentTime.toISOString()}\n24hå‰: ${time24hAgo.toISOString()}\næ—¶é—´å·®: ${(currentTime - time24hAgo) / (1000 * 60 * 60)} å°æ—¶`;
                }
            },
            {
                name: "æ­¥éª¤ 6: ğŸ” åœ¨ allData ä¸­ç»Ÿè®¡ 24h sell ä¿¡å·ï¼ˆæ–¹æ³•1ï¼šä»åå‘å‰éå†ï¼‰",
                run: async () => {
                    const currentTime = stepData.currentTime;
                    const time24hAgo = stepData.time24hAgo;
                    
                    let count24h = 0;
                    let matchedCount = 0;
                    let matchedItems = [];
                    
                    // æ–¹æ³•1ï¼šä»åå‘å‰éå†ï¼ˆå®é™…é¡µé¢ä½¿ç”¨çš„æ–¹æ³•ï¼‰
                    for (let i = stepData.allData.length - 1; i >= 0; i--) {
                        const checkTime = new Date(stepData.allData[i].time);
                        if (checkTime > currentTime) continue;
                        if (checkTime < time24hAgo) break;
                        matchedCount++;
                        if (stepData.allData[i].signal_type === 'sell') {
                            count24h++;
                            matchedItems.push(stepData.allData[i]);
                        }
                    }
                    
                    stepData.count24h_method1 = count24h;
                    stepData.matchedCount_method1 = matchedCount;
                    stepData.matchedItems_method1 = matchedItems;
                    
                    return `æ–¹æ³•1ï¼ˆä»åå‘å‰ï¼‰:\nåŒ¹é…æ•°æ®ç‚¹: ${matchedCount} ä¸ª\nsell ä¿¡å·: ${count24h} æ¬¡\n\nå‰5ä¸ª sell ä¿¡å·:\n${matchedItems.slice(0, 5).map(item => `  ${item.time} ${item.coin} ${item.signal_type}`).join('\n')}`;
                }
            },
            {
                name: "æ­¥éª¤ 7: ğŸ” åœ¨ allData ä¸­ç»Ÿè®¡ 24h sell ä¿¡å·ï¼ˆæ–¹æ³•2ï¼šfilterï¼‰",
                run: async () => {
                    const currentTime = stepData.currentTime;
                    const time24hAgo = stepData.time24hAgo;
                    
                    const currentTimeMs = currentTime.getTime();
                    const time24hAgoMs = time24hAgo.getTime();
                    
                    const matchedItems = stepData.allData.filter(item => {
                        const itemTime = new Date(item.time).getTime();
                        return itemTime > time24hAgoMs && itemTime <= currentTimeMs && item.signal_type === 'sell';
                    });
                    
                    const count24h = matchedItems.length;
                    
                    stepData.count24h_method2 = count24h;
                    stepData.matchedItems_method2 = matchedItems;
                    
                    return `æ–¹æ³•2ï¼ˆfilterï¼‰:\nsell ä¿¡å·: ${count24h} æ¬¡\n\nå‰5ä¸ª sell ä¿¡å·:\n${matchedItems.slice(0, 5).map(item => `  ${item.time} ${item.coin} ${item.signal_type}`).join('\n')}`;
                }
            },
            {
                name: "æ­¥éª¤ 8: âš ï¸ å¯¹æ¯”ä¸¤ç§æ–¹æ³•çš„ç»“æœ",
                run: async () => {
                    const method1 = stepData.count24h_method1;
                    const method2 = stepData.count24h_method2;
                    const match = method1 === method2;
                    
                    return `æ–¹æ³•1 ç»“æœ: ${method1} æ¬¡\næ–¹æ³•2 ç»“æœ: ${method2} æ¬¡\nç»“æœ${match ? 'ä¸€è‡´' : 'ä¸ä¸€è‡´'} ${match ? 'âœ…' : 'âŒ'}`;
                }
            },
            {
                name: "æ­¥éª¤ 9: ğŸ” éå†æ‰€æœ‰ displayDataï¼Œè®¡ç®—æ¯ä¸ªç‚¹çš„ 24h ç»Ÿè®¡",
                run: async () => {
                    const sell24hData = [];
                    
                    stepData.displayData.forEach((displayPoint, displayIndex) => {
                        const currentTime = new Date(displayPoint.time);
                        const time24hAgo = new Date(currentTime - 24 * 60 * 60 * 1000);
                        
                        let count24h = 0;
                        for (let i = stepData.allData.length - 1; i >= 0; i--) {
                            const checkTime = new Date(stepData.allData[i].time);
                            if (checkTime > currentTime) continue;
                            if (checkTime < time24hAgo) break;
                            if (stepData.allData[i].signal_type === 'sell') count24h++;
                        }
                        
                        sell24hData.push(count24h);
                    });
                    
                    stepData.sell24hData = sell24hData;
                    
                    return `ç”Ÿæˆ sell24hData æ•°ç»„:\né•¿åº¦: ${sell24hData.length}\næœ€å 10 ä¸ªå€¼: ${sell24hData.slice(-10).join(', ')}\næœ€åä¸€ä¸ªå€¼: ${sell24hData[sell24hData.length - 1]}`;
                }
            },
            {
                name: "æ­¥éª¤ 10: ğŸ”§ åˆ›å»º chartData24hï¼ˆå¤åˆ¶ sell24hDataï¼‰",
                run: async () => {
                    const chartData24h = stepData.sell24hData.slice();
                    
                    stepData.chartData24h = chartData24h;
                    
                    const match = chartData24h[chartData24h.length - 1] === stepData.sell24hData[stepData.sell24hData.length - 1];
                    
                    return `chartData24h = sell24hData.slice();\n\nchartData24h é•¿åº¦: ${chartData24h.length}\nchartData24h æœ€åä¸€ä¸ªå€¼: ${chartData24h[chartData24h.length - 1]}\nsell24hData æœ€åä¸€ä¸ªå€¼: ${stepData.sell24hData[stepData.sell24hData.length - 1]}\n\nå€¼${match ? 'ä¸€è‡´' : 'ä¸ä¸€è‡´'} ${match ? 'âœ…' : 'âŒ'}`;
                }
            },
            {
                name: "æ­¥éª¤ 11: ğŸ¯ æ¨¡æ‹Ÿ Tooltip è·å–å€¼ï¼ˆæœ€åä¸€ä¸ªç‚¹ï¼‰",
                run: async () => {
                    const dataIndex = stepData.chartData24h.length - 1;
                    const tooltipValue = stepData.chartData24h[dataIndex];
                    const expectedValue = stepData.sell24hData[dataIndex];
                    
                    stepData.tooltipValue = tooltipValue;
                    stepData.expectedValue = expectedValue;
                    
                    const match = tooltipValue === expectedValue;
                    
                    return `dataIndex: ${dataIndex}\ntooltip è·å–çš„å€¼: chartData24h[${dataIndex}] = ${tooltipValue}\né¢„æœŸå€¼: sell24hData[${dataIndex}] = ${expectedValue}\n\nç»“æœ${match ? 'ä¸€è‡´' : 'ä¸ä¸€è‡´'} ${match ? 'âœ…' : 'âŒ'}`;
                }
            },
            {
                name: "æ­¥éª¤ 12: ğŸ” æœ€ç»ˆå¯¹æ¯”",
                run: async () => {
                    return `é¡¶éƒ¨ç»Ÿè®¡æ˜¾ç¤º: 186 æ¬¡\ntooltip åº”è¯¥æ˜¾ç¤º: ${stepData.expectedValue} æ¬¡\ntooltip å®é™…æ˜¾ç¤º: ${stepData.tooltipValue} æ¬¡\n\n${stepData.expectedValue === 186 ? 'âœ… æ­£ç¡®' : 'âŒ é”™è¯¯'}`;
                }
            }
        ];

        function createStepElement(index) {
            const step = steps[index];
            const div = document.createElement('div');
            div.id = `step${index}`;
            div.className = 'step';
            div.innerHTML = `
                <div class="step-title">${step.name}</div>
                <div id="step${index}-content">ç­‰å¾…æ‰§è¡Œ...</div>
            `;
            return div;
        }

        function initSteps() {
            const container = document.getElementById('steps');
            container.innerHTML = '';
            steps.forEach((step, index) => {
                container.appendChild(createStepElement(index));
            });
        }

        async function runStep(index) {
            if (index >= steps.length) {
                displayFinalResult();
                return;
            }
            
            currentStep = index;
            const stepEl = document.getElementById(`step${index}`);
            const contentEl = document.getElementById(`step${index}-content`);
            
            stepEl.className = 'step running';
            contentEl.innerHTML = 'â³ æ‰§è¡Œä¸­...';
            
            try {
                const result = await steps[index].run();
                contentEl.innerHTML = `<pre>${result}</pre>`;
                stepEl.className = 'step success';
                
                // æ»šåŠ¨åˆ°å½“å‰æ­¥éª¤
                stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } catch (error) {
                contentEl.innerHTML = `<span class="error">âŒ é”™è¯¯: ${error.message}</span>`;
                stepEl.className = 'step error';
            }
        }

        async function runAll() {
            reset();
            for (let i = 0; i < steps.length; i++) {
                await runStep(i);
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }

        function reset() {
            currentStep = 0;
            stepData = {};
            initSteps();
        }

        function displayFinalResult() {
            const container = document.getElementById('steps');
            const resultDiv = document.createElement('div');
            resultDiv.className = 'step ' + (stepData.tooltipValue === stepData.expectedValue ? 'success' : 'error');
            resultDiv.innerHTML = `
                <div class="step-title">ğŸ“Š æœ€ç»ˆç»“æœ</div>
                <div class="comparison">
                    <div class="comparison-box ${stepData.expectedValue === 186 ? 'match' : 'mismatch'}">
                        <h3>é¢„æœŸå€¼</h3>
                        <div class="bignum ${stepData.expectedValue === 186 ? 'success' : 'error'}">${stepData.expectedValue}</div>
                        <p>æ¥æº: sell24hData è®¡ç®—ç»“æœ</p>
                    </div>
                    <div class="comparison-box ${stepData.tooltipValue === 186 ? 'match' : 'mismatch'}">
                        <h3>Tooltip æ˜¾ç¤ºå€¼</h3>
                        <div class="bignum ${stepData.tooltipValue === 186 ? 'success' : 'error'}">${stepData.tooltipValue}</div>
                        <p>æ¥æº: chartData24h[dataIndex]</p>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 20px; font-size: 18px;">
                    ${stepData.tooltipValue === 186 ? 
                        '<span class="success">âœ… æ­£ç¡®ï¼Tooltip æ˜¾ç¤ºçš„å€¼ä¸é¢„æœŸä¸€è‡´</span>' : 
                        `<span class="error">âŒ é”™è¯¯ï¼é¢„æœŸ ${stepData.expectedValue}ï¼Œä½† Tooltip æ˜¾ç¤º ${stepData.tooltipValue}</span>`
                    }
                </div>
            `;
            container.appendChild(resultDiv);
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // åˆå§‹åŒ–
        initSteps();
    </script>
</body>
</html>
